diff --git i/media/engine/webrtc_video_engine.cc w/media/engine/webrtc_video_engine.cc
index 587d9b4538..7f1c0c1068 100644
--- i/media/engine/webrtc_video_engine.cc
+++ w/media/engine/webrtc_video_engine.cc
@@ -967,6 +967,7 @@ WebRtcVideoSendChannel::WebRtcVideoSendStream::ConfigureVideoEncoderSettings(
     auto composition_time_supported = webrtc::RtpExtension::FindHeaderExtensionByUri(
         parameters_.config.rtp.extensions, webrtc::RtpExtension::kCompositionTimeUri, 
         webrtc::RtpExtension::Filter::kDiscardEncryptedExtension);
+    RTC_LOG(LS_INFO) << "HOGE: H264 composition_time_supported: " << (composition_time_supported != nullptr ? "t" : "f" );
     if (composition_time_supported != nullptr)
     {
       h264_settings.bframe_enabled = true;
@@ -986,6 +987,7 @@ WebRtcVideoSendChannel::WebRtcVideoSendStream::ConfigureVideoEncoderSettings(
     auto composition_time_supported = webrtc::RtpExtension::FindHeaderExtensionByUri(
         parameters_.config.rtp.extensions, webrtc::RtpExtension::kCompositionTimeUri, 
         webrtc::RtpExtension::Filter::kDiscardEncryptedExtension);
+    RTC_LOG(LS_INFO) << "HOGE: H265 composition_time_supported: " << (composition_time_supported != nullptr ? "t" : "f" );
     if (composition_time_supported != nullptr)
     {
       h265_settings.bframe_enabled = true;
diff --git i/modules/rtp_rtcp/source/video_rtp_depacketizer_h265.cc w/modules/rtp_rtcp/source/video_rtp_depacketizer_h265.cc
index 3f7a4b8cac..d8a546c1d5 100644
--- i/modules/rtp_rtcp/source/video_rtp_depacketizer_h265.cc
+++ w/modules/rtp_rtcp/source/video_rtp_depacketizer_h265.cc
@@ -115,7 +115,7 @@ absl::optional<VideoRtpDepacketizer::ParsedRtpPayload> ProcessApOrSingleNalu(
     }
 
     // Insert start code before each NALU in aggregated packet.
-    video_payload.AppendData(kStartCode);
+    // video_payload.AppendData(kStartCode);
     video_payload.AppendData(&payload_data[start_offset],
                              end_offset - start_offset);
 
@@ -265,7 +265,7 @@ absl::optional<VideoRtpDepacketizer::ParsedRtpPayload> ParseFuNalu(
     rtp_payload.MutableData()[1] = layer_id_l_unshifted | tid;
     rtc::CopyOnWriteBuffer video_payload;
     // Insert start code before the first fragment in FU.
-    video_payload.AppendData(kStartCode);
+    // video_payload.AppendData(kStartCode);
     video_payload.AppendData(rtp_payload);
     parsed_payload->video_payload = video_payload;
   } else {
diff --git i/sdk/objc/components/video_codec/RTCDefaultVideoEncoderFactory.m w/sdk/objc/components/video_codec/RTCDefaultVideoEncoderFactory.m
index 9dee352740..6b66b9dda4 100644
--- i/sdk/objc/components/video_codec/RTCDefaultVideoEncoderFactory.m
+++ w/sdk/objc/components/video_codec/RTCDefaultVideoEncoderFactory.m
@@ -34,6 +34,7 @@ @implementation RTC_OBJC_TYPE (RTCDefaultVideoEncoderFactory)
 #ifdef RTC_ENABLE_BFRAME
 - (instancetype)initWithBframe:(BOOL)enableBframe {
   if (self = [super init]) {
+    NSLog(@"HOGE: %s enableBframe: %d", __func__, enableBframe);
     self.bframeEnabled = enableBframe;
   }
   return self;
@@ -46,8 +47,12 @@ - (instancetype)initWithBframe:(BOOL)enableBframe {
 + (NSArray<RTC_OBJC_TYPE(RTCVideoCodecInfo) *> *)supportedCodecsWithBframe:(BOOL)enableBframe {
 
   BOOL enableH264Bframe = enableBframe && [RTCVideoEncoderH264 isBframeSupported];
+
+  NSLog(@"HOGE: %s:%d enableBframe: %d", __func__, __LINE__, enableBframe);
+  NSLog(@"HOGE: %s:%d enableH264Bframe: %d", __func__, __LINE__, enableH264Bframe);
 # ifdef RTC_ENABLE_H265
   BOOL enableH265Bframe = enableBframe && [RTCVideoEncoderH265 isBframeSupported];
+  NSLog(@"HOGE: %s%d enableH265Bframe: %d", __func__, __LINE__, enableH265Bframe);
 # endif // RTC_ENABLE_H265
 #else // RTC_ENABLE_BFRAME
 + (NSArray<RTC_OBJC_TYPE(RTCVideoCodecInfo) *> *)supportedCodecs {
@@ -121,7 +126,8 @@ - (instancetype)initWithBframe:(BOOL)enableBframe {
 
 #ifdef RTC_ENABLE_BFRAME
 + (NSArray<RTC_OBJC_TYPE(RTCVideoCodecInfo) *> *)supportedCodecs {
-  return [self supportedCodecsWithBframe:NO];
+  // return [self supportedCodecsWithBframe:NO];
+  return [self supportedCodecsWithBframe:YES];
 }
 #endif // RTC_ENABLE_BFRAME
 
diff --git i/sdk/objc/components/video_codec/RTCVideoDecoderH265.mm w/sdk/objc/components/video_codec/RTCVideoDecoderH265.mm
index 007121727f..9f602d1dd0 100644
--- i/sdk/objc/components/video_codec/RTCVideoDecoderH265.mm
+++ w/sdk/objc/components/video_codec/RTCVideoDecoderH265.mm
@@ -349,6 +349,7 @@ - (NSInteger)decodeData:(const uint8_t *)data size:(size_t)size timeStamp:(int64
   auto frameType = nalu_parser::GetH265FrameType(inputImage.buffer);
   frameDecodeParams->timestampComposition = inputImage.timestampComposition;
   frameDecodeParams->frameType = frameType;
+  RTC_LOG(LS_INFO) << "HOGE: frameType: " << nalu_parser::FrameTypeToString(frameType);
   {
     std::lock_guard lockGuard(_decodeFrameParamsQueueMutex);
     _decodeFrameParamsQueue.push_back(RTCDecodeQueueParams(timeStamp));
diff --git i/sdk/objc/components/video_codec/RTCVideoEncoderH264.mm w/sdk/objc/components/video_codec/RTCVideoEncoderH264.mm
index 07ec47538f..caea3648a7 100644
--- i/sdk/objc/components/video_codec/RTCVideoEncoderH264.mm
+++ w/sdk/objc/components/video_codec/RTCVideoEncoderH264.mm
@@ -381,7 +381,7 @@ - (instancetype)initWithCodecInfo:(RTC_OBJC_TYPE(RTCVideoCodecInfo) *)codecInfo
     _profile_level_id =
         webrtc::ParseSdpForH264ProfileLevelId([codecInfo nativeSdpVideoFormat].parameters);
     //START:RTC_ENABLE_BFRAME
-    _bframeEnabled = [codecInfo nativeSdpVideoFormat].bframe_enabled;
+    _bframeEnabled = true; // [codecInfo nativeSdpVideoFormat].bframe_enabled;
     //END:RTC_ENABLE_BFRAME
     
     RTC_DCHECK(_profile_level_id);
@@ -411,7 +411,7 @@ - (NSInteger)startEncodeWithSettings:(RTC_OBJC_TYPE(RTCVideoEncoderSettings) *)s
   _mode = settings.mode;
 
   //START:RTC_ENABLE_BFRAME
-  _bframeEnabled = settings.bframeEnabled;
+  _bframeEnabled = true; // settings.bframeEnabled;
   RTC_LOG(LS_INFO) << "[H264Encoder] B-frame is " << (_bframeEnabled ? "enabled" : "disabled");
   //END:RTC_ENABLE_BFRAME
 
@@ -713,13 +713,13 @@ - (int)resetCompressionSessionWithPixelFormat:(OSType)framePixelFormat {
     return WEBRTC_VIDEO_CODEC_ERROR;
   }
 #ifdef RTC_ENABLE_BFRAME
-#  if defined(WEBRTC_IOS)
+// #  if defined(WEBRTC_IOS) // 実験中
   if (_bframeEnabled) {
-    RTC_LOG(LS_INFO) << "[H264Encoder] Enabling kVTCompressionPropertyKey_AllowFrameReordering...";
+    RTC_LOG(LS_INFO) << "HOGE: [H264Encoder] Enabling kVTCompressionPropertyKey_AllowFrameReordering...";
     SetVTSessionProperty(_compressionSession,
                                  kVTCompressionPropertyKey_AllowFrameReordering,
                                  true);
-
+    RTC_LOG(LS_INFO) << "HOGE: SetVTSessionProperty status: " << status;
     // status = VTSessionSetProperty(_compressionSession,
     //                              kVTCompressionPropertyKey_NumberOfPendingFrames,
     //                              (__bridge CFNumberRef)(@(10)));
@@ -727,7 +727,7 @@ - (int)resetCompressionSessionWithPixelFormat:(OSType)framePixelFormat {
     RTC_LOG(LS_INFO) << "[H264Encoder] B-frame is disabled";
     SetVTSessionProperty(_compressionSession, kVTCompressionPropertyKey_AllowFrameReordering, false);
   }
-#  endif
+// #  endif
 #endif // RTC_ENABLE_BFRAME
 
 #if defined(WEBRTC_MAC) && !defined(WEBRTC_IOS)
@@ -755,7 +755,7 @@ - (void)configureCompressionSession {
                        ExtractProfile(*_profile_level_id));
 #ifdef RTC_ENABLE_BFRAME
   if (_bframeEnabled) {
-    RTC_LOG(LS_INFO) << "[H264Encoder] Enabling kVTCompressionPropertyKey_AllowFrameReordering in configureCompressionSession...";
+    RTC_LOG(LS_INFO) << "HOGE: [H264Encoder] Enabling kVTCompressionPropertyKey_AllowFrameReordering in configureCompressionSession...";
     SetVTSessionProperty(_compressionSession,
                                  kVTCompressionPropertyKey_AllowFrameReordering,
                                  true);
@@ -933,7 +933,7 @@ - (void)frameWasEncoded:(OSStatus)status
     nalu_parser::FrameType frameType = nalu_parser::GetH264FrameType(buffer->data(), buffer->size());
     
     RTC_LOG(LS_VERBOSE)
-    << "[H264Encoder] DTS: " << timestamp
+    << "HOGE: [H264Encoder] DTS: " << timestamp
     << ", CTS: " << frame.timestampComposition
     << ", PTS: " << renderTimeMs
     << ", " << nalu_parser::FrameTypeToString(frameType);
diff --git i/sdk/objc/components/video_codec/RTCVideoEncoderH265.mm w/sdk/objc/components/video_codec/RTCVideoEncoderH265.mm
index d67b4e63fa..7df68de93e 100644
--- i/sdk/objc/components/video_codec/RTCVideoEncoderH265.mm
+++ w/sdk/objc/components/video_codec/RTCVideoEncoderH265.mm
@@ -230,7 +230,7 @@ - (instancetype)initWithCodecInfo:(RTC_OBJC_TYPE(RTCVideoCodecInfo)*)codecInfo {
     _isLowLatencyEnabled = true;
 
     //START:RTC_ENABLE_BFRAME
-    _bframeEnabled = [codecInfo nativeSdpVideoFormat].bframe_enabled;
+    _bframeEnabled = true; // [codecInfo nativeSdpVideoFormat].bframe_enabled;
     RTC_LOG(LS_INFO) << "[H265Encoder] B-frame is " << (_bframeEnabled ? "enabled" : "disabled");
     //END:RTC_ENABLE_BFRAME
     
@@ -264,7 +264,7 @@ - (NSInteger)startEncodeWithSettings:(RTC_OBJC_TYPE(RTCVideoEncoderSettings)*)se
   _mode = settings.mode;
 
   //START:RTC_ENABLE_BFRAME
-  _bframeEnabled = settings.bframeEnabled;
+  _bframeEnabled = true; // settings.bframeEnabled;
   RTC_LOG(LS_INFO) << "[H264Encoder] B-frame is " << (_bframeEnabled ? "enabled" : "disabled");
   //END:RTC_ENABLE_BFRAME
 
@@ -518,20 +518,20 @@ - (int)resetCompressionSession {
     return WEBRTC_VIDEO_CODEC_ERROR;
   }
 #ifdef RTC_ENABLE_BFRAME
-#  if defined(WEBRTC_IOS)
+// #  if defined(WEBRTC_IOS) // 実験中
   if (_bframeEnabled) {
     RTC_LOG(LS_INFO) << "[H265Encoder] Enabling kVTCompressionPropertyKey_AllowFrameReordering...";
     SetVTSessionProperty(_compressionSession,
                                  kVTCompressionPropertyKey_AllowFrameReordering,
                                  true);
-
+    RTC_LOG(LS_INFO) << "HOGE: SetVTSessionProperty status: " << status;
     // status = VTSessionSetProperty(_compressionSession,
     //                              kVTCompressionPropertyKey_NumberOfPendingFrames,
     //                              (__bridge CFNumberRef)(@(10)));
   } else {
     RTC_LOG(LS_INFO) << "[H265Encoder] B-frame is disabled";
   }
-#  endif
+// #  endif
 #endif // RTC_ENABLE_BFRAME
 
 #if defined(WEBRTC_MAC) && !defined(WEBRTC_IOS)
@@ -670,13 +670,13 @@ - (void)frameWasEncoded:(OSStatus)status
   }
 
   if (isKeyframe) {
-    RTC_LOG(LS_INFO) << "Generated keyframe";
+    RTC_LOG(LS_INFO) << "HOGE: Generated keyframe";
   }
 
   std::unique_ptr<rtc::Buffer> buffer(new rtc::Buffer());
   if (_useAnnexB) {
     if (!webrtc::H265CMSampleBufferToAnnexBBuffer(sampleBuffer, isKeyframe, buffer.get())) {
-      RTC_LOG(LS_WARNING) << "Unable to parse H265 encoded buffer";
+      RTC_LOG(LS_WARNING) << "HOGE: Unable to parse H265 encoded buffer";
       return;
     }
   } else {
@@ -688,7 +688,7 @@ - (void)frameWasEncoded:(OSStatus)status
       char* data = nullptr;
       size_t length;
       if (auto error = CMBlockBufferGetDataPointer(blockBuffer, currentStart, &length, nullptr, &data)) {
-        RTC_LOG(LS_ERROR) << "H264 decoder: CMBlockBufferGetDataPointer failed with error " << error;
+        RTC_LOG(LS_ERROR) << "HOGE: H264 decoder: CMBlockBufferGetDataPointer failed with error " << error;
         return;
       }
       buffer->AppendData(data, size);
@@ -743,10 +743,10 @@ - (void)frameWasEncoded:(OSStatus)status
     nalu_parser::FrameType frameType = nalu_parser::GetH265FrameType(frame.buffer);
     
     RTC_LOG(LS_VERBOSE)
-    << "[H265Encoder] DTS: " << timestamp
+    << "HOGE: [H265Encoder] DTS: " << timestamp
     << ", CTS: " << frame.timestampComposition
     << ", PTS: " << renderTimeMs
-    << ", " << nalu_parser::FrameTypeToString(frameType);
+    << ", " << nalu_parser::FrameTypeToString(frameType) << ", size: " << frame.buffer.length;
   }
 # endif // RTC_ENABLE_BFRAME_TEST
 #endif // RTC_ENABLE_BFRAME
@@ -754,7 +754,7 @@ - (void)frameWasEncoded:(OSStatus)status
 
   BOOL res = _callback(frame, [[RTC_OBJC_TYPE(RTCCodecSpecificInfoH265) alloc] init]);
   if (!res) {
-    RTC_LOG(LS_ERROR) << "Encode callback failed.";
+    RTC_LOG(LS_ERROR) << "HOGE: Encode callback failed.";
     return;
   }
   _bitrateAdjuster->Update(frame.buffer.length);
